你已经学会了如何启动一组 Goroutine 并统一处理它们的错误和取消信号。但现在有一个新问题：如果我们一次收到 1000 个 NATS 消息，errgroup 会毫不犹豫地为你启动 1000 个 Goroutine。这可能会瞬间耗尽你服务器的内存和 CPU 资源，导致服务崩溃。

我们需要一个“门卫”，来限制能同时进入“处理中”状态的 Goroutine 数量。这个“门卫”就是信号量 (Semaphore)。

知识点 2: 使用带缓冲的 Channel 作为信号量来限制并发
核心思想: Go 语言中没有一个现成的 Semaphore 类型，但我们可以用一个带缓冲的 Channel 非常巧妙地实现它。想象一个容量为 N 的篮子，里面放了 N 个令牌。每个 Goroutine 在开始工作前，必须从篮子里拿到一个令牌。如果篮子是空的，它就必须等待。工作完成后，它必须把令牌放回篮子。这样，我们就能保证同时工作的 Goroutine 数量永远不会超过 N。

输入 (Input):

一个整数 N，代表你希望的最大并发数。

一组数量可能大于 N 的并发任务。

输出 (Output):

一个稳定的系统，其并发执行的任务数量始终被控制在 N 以内。

示例例子: 模拟一个网站爬虫
假设我们要同时爬取 10 个网站的首页，但是为了避免对目标服务器造成太大压力，我们希望最多只同时爬取 3 个。

下面的代码演示了如何使用信号量来做到这一点。请再次保存并运行它。

运行结果分析:

当你运行代码时，请密切观察日志打印的时间戳。你会发现：

程序会立刻打印 3 条 开始爬取... 的日志，因为信号量的容量是 3。

然后程序会暂停一下，直到这 3 个任务中的某一个打印了 完成爬取...。

一旦有任务完成并释放了令牌，程序会立刻再打印一条新的 开始爬取... 日志，以填补空出的并发位。

整个过程中，"正在爬取"（即 开始 和 完成 之间）的任务数量，永远不会超过 3 个。

动手实践的例子:
现在，请你来扮演系统管理员的角色。

将 maxConcurrency 的值从 3 修改为 5。重新运行程序，观察“开始爬取”的日志打印行为有什么变化？

假设服务器资源非常紧张，将 maxConcurrency 改为 1。再次运行程序，观察任务的执行模式变成了什么样子？

这个练习能让你直观地感受到，通过调整一个参数，就可以精确地控制整个系统的并发压力。完成后，告诉我你的观察，我们再进入最后一个知识点：超时控制。