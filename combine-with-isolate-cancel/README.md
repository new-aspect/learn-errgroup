好的，我们开始构建这个全新的技术原型。这个练习的目标是**绝对的隔离**：一个任务的失败（在这里特指“超时”）绝对不能影响任何其他任务的执行。它们之间唯一的共享资源就是“并发许可”。

这个要求和我们之前讨论的 `errgroup` 有一个核心不同：`errgroup` 的设计哲学是“一损俱损”，一个出错，全体取消。而现在，我们需要的是“各自为战，自负盈亏”。

因此，这次我们将不使用 `errgroup`，而是使用 Go 语言更基础的 `sync.WaitGroup`，因为它能完美地实现我们“只等待，不干涉”的目标。

---

### **总任务: 构建一个完全隔离的并发任务处理器**

**场景**: 我们有一个消息队列消费者，它不断地从队列中接收任务。我们需要处理这一批共15个任务。

* **任务行为**:
    * 有12个是“普通任务”，处理它们需要 `1` 秒。
    * 有3个是“慢任务”，处理它们需要 `5` 秒。
* **处理规则**:
    * 最大并发数: **3**。
    * **每个任务**都有自己独立的超时时间：**2秒**。如果一个任务超过2秒还没完成，它就算失败，但**绝对不能**影响其他任务。

#### **输入 (Input) / 给你的已知条件:**

1.  **任务总数**: 15个。
2.  **并发限制**: 3。
3.  **单个任务超时**: 2秒。

#### **输出 (Output) / 你需要编写的代码要达成的目标:**

你的 `main.go` 运行后，日志应该能清晰地展示以下几点：

1.  **并发控制**: 同时开始执行的任务（打印“开始”日志）永远不会超过3个。
2.  **任务隔离**:
    * 你会看到“慢任务”因为超过2秒而被判定为“超时失败”。
    * 你也会看到“普通任务”在1秒后被判定为“执行成功”。
    * 最重要的是，一个慢任务的超时**不会**导致任何一个普通任务被取消或中断。它们会继续执行直到完成。
3.  **程序结束**: 程序会在所有15个任务都得出自己的结论（要么成功，要么超时）后，最终优雅地退出。

---

#### **你的任务:**

请在一个空白的 `main.go` 文件中开始编码。

**提示**:
* 你需要一个 `for` 循环来派发所有15个任务。
* 你需要一个**信号量** (带缓冲的 channel) 来控制并发。
* 你需要一个 `sync.WaitGroup`。在每个 Goroutine 启动前调用 `wg.Add(1)`，在 Goroutine 结束时（无论成功还是超时）调用 `wg.Done()`。
* 在 `main` 函数的最后，你需要调用 `wg.Wait()` 来等待所有任务结束。
* 在 Goroutine 内部，为**每个任务**创建一个**新的、独立的** `context.WithTimeout`。

开始吧！把你的代码贴出来，我们一起看看结果。